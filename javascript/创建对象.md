创建对象
=======

###工厂模式

```js
	function ellyLiang(name, age, job) {
        var o = new Object();
        o.name = name;
        o.age = age;
        o.job = job;
        o.getName = function() {
            alert(this.name);
        };

        return o;
    }
    var person1 = ellyLiang("useLess", 24, "FF");
    var person2 = ellyLiang("elly", 23, "none");
```

工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别问题（即怎么知道一个对象的类型）

###构造函数模式

```js
	function Ellyliang(name, age, job) {
        this.name = name;
        this.age = age;
        this.job = job;
        this.getName = function() {
            console.log(this.name);
        };
    }
    var person1 = new Ellyliang("useLess", 24, "FF");
    var person2 = new Ellyliang("elly", 23, "none");
```

构造函数始终以大写字母开头，非构造函数以一个小写字母开头。
要创建Person的新实例，必须使用new操作符。

####构造函数与其他函数的区别在于他的调用方式的不同。

任何函数，只要通过new操作符来调用，那它就可以作为构造函数；而任何函数，如果它不通过new操作符来调用，那它跟普通函数也不会有什么两样。

```js
	//当作构造函数来使用
    var person = new Ellyliang("useLess", 24, "FF");
    person.getName(); //"useLess"

    //当作普通函数调用
    Ellyliang("elly", 23, "none"); //添加到window
    window.getName(); //"elly"

    //在另一个对象作用域中调用
    var o = new Object();
    Ellyliang.call(o, "LCM", 22, "student");
    o.getName(); //"LCM" 
```

####构造函数的问题：每个方法都要在每个实例上面重新创建一遍

不同实例上的同名函数是不相等的。

解决方法：

```js
	function Ellyliang(name, age, job) {
		this.name = name;
		this.age = age;
		this.job = job;
		this.getName = getName;
	}

	function getName() {
		console.log(this.name);
	}
```

如果对象需要定义很多方法，那么就要定义很多个全局函数，于是这个自定义的引用类型就丝毫没有封装性可言了


















